# Atlas.Orm

> No annotations. No migrations. No lazy loading. No data-type abstractions.

Atlas is a [data mapper](http://martinfowler.com/eaaCatalog/dataMapper.html)
implementation for a **persistence model** (*not* a domain model).

As such, Atlas uses the term "record" to indicate that its objects are *not*
domain entities. Note that an Atlas record is a *passive* record, not an [active
record](http://martinfowler.com/eaaCatalog/activeRecord.html); it is
disconnected from the database. Use Atlas records as a way to populate
domain entities, or use them directly for simple data source interactions.

Atlas is stable for production use. Please send bug reports and pull requests!

Documentation is in [the docs directory](./docs/index.md).

## Rationale

(Or, "Why does Atlas exist?")

The desire was for an alternative to Active Record allowing developers to get
started as easily as an Active Record implementation for the *persistence* model,
and then refactor more easily towards a richer *domain* model as needed.

Using a table data gateway for the underlying table Rows, then composing them
into Records and RecordSets via a data mapper, does the trick. As simple behaviors
begin to be needed, they can be added to the Record and RecordSet persistence
model objects. (Rows do not have behavior.) The domain logic layer (e.g. a
service layer) can then use them as needed.

However, per [this article from Mehdi Khalili][mkap], the target end-state for
modeling should eventually move toward "Domain Model composed of Persistence Model".
That is, the domain Entity and Aggregate classes might use data source Records and
RecordSets internally, but will not expose them. They can manipulate the persistence
model objects internally as much as they wish.
E.g., an Entity might have a `getAddress()`method and read from the internal
Record (which in turn reads from its internal Row or Related objects).
Alternatively, the end state might be "DDD on top of ORM" where Repositories map
the persistence model objects to domain Entities, Value Objects, and Aggregates.

A persistence model alone should get the app a long way, especially at the beginning
of a project. Even so, the Row, Record, and RecordSet objects are disconnected
from the database, which should make the refactoring process a lot cleaner than
with Active Record.

[mkap]: http://www.mehdi-khalili.com/orm-anti-patterns-part-4-persistence-domain-model

Other rationalizations, essentially based around things *not* wanted in this ORM:

- No annotations. Code to be in code, not in comments.

- No migrations or other table-modification logic. Many ORMs read the PHP objects
and create, or modify, tables from them. Atlas.Orm wanted the persistence system to be
a *model* of the schema, not a *creator* of it. If migrations are needed, use
a tool specifically for migrations.

- No lazy-loading. Lazy-loading is seductive but eventually is more trouble than
it's worth; Atlas.Orm doesn't make it available at all, so it cannot accidentally
be invoked.

- No data-type abstractions. Previously, data-type abstraction was thought to be great,
but this also turns out to not be worth the cost. Therefore the actual underlying
database types are exposed and available as much as possible.

Possible deal-breakers for potential users:

- Atlas uses code generation, though only in a very limited way. It turns out that
code generation is useful for building the SQL table classes. Each table is described
as a PHP class, one that returns things like table name, column names, etc. This is
the only class that really gets generated by Atlas.Orm; the others are empty extensions
of parent classes.

- Atlas uses base Row, Record, and RecordSet classes, instead of plain-old PHP
objects. If this were a domain modeling system, a base class would be unacceptable.
Because Atlas.Orm is a *persistence* modeling system, making a base class less
objectionable, but for some this may be undesired.

Finally, Atlas supports **composite primary keys** and **composite foreign
keys.** Performance in these cases is sure to be slower, but it is in fact
supported.
